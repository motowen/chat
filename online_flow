Client A        WS Server 1         Redis        NATS Pub/Sub        WS Server 2        Client B
   |                 |                 |               |                  |                 |
   |--- WebSocket --->|                 |               |                  |                 |
   |                 |--- SET user:123=online -------->|               |                  |
   |                 |                 |               |                  |                 |
   |                 |--- Publish(user:123 online) --->|----------------->|                  |
   |                 |                 |               |--- event ------->|--- notify B --->|
   |                 |                 |               |                  |                 |
   |  <--- pong ---- |                 |               |                  |                 |
   |--- ping ------->|                 |               |                  |                 |
   |                 |                 |               |                  |                 |
... (持續連線) ...
   |                 |                 |               |                  |                 |
[Client A 關閉連線/掉線]
   |--- (disconnect)|                 |               |                  |                 |
   |                 |--- SET user:123=offline ------>|               |                  |
   |                 |--- Publish(user:123 offline) ->|----------------->|                  |
   |                 |                 |               |--- event ------->|--- notify B --->|
   |                 |                 |               |                  |                 |


🔹 流程解釋
Client A 上線
與 WS Server 1 建立 WebSocket。
Server 1 在 Redis 寫入狀態 = online。
同時透過 NATS/Redis PubSub 廣播 "user:123 online"。
Client B 訂閱到事件
Client B 連到 WS Server 2。
WS Server 2 收到 NATS 廣播 → 轉發給 Client B → 即時顯示 A 上線。
心跳存活
Client A 與 WS Server 1 定期交換 ping/pong，確保連線正常。
若超時未收到 pong，Server 1 認定 Client A 掉線。
Client A 離線
連線斷開時，Server 1 更新 Redis → user:123=offline。
廣播 user:123 offline 給所有 WS Server。
WS Server 2 通知 Client B → 立刻顯示 A 離線。

🔹 好處
低延遲：NATS/Redis PubSub 事件傳播通常在毫秒級。
多實例同步：無論 A/B 連到哪個 WS Server，都能即時知道對方狀態。
API 查詢一致性：好友列表查詢時直接讀 Redis，不必依賴 WS。

Redis:
🔹 1. 單用戶狀態存儲
目前你是 online_status:{userId} → string，這樣可以，但有幾個優化點。
建議改成 Hash
HSET online_status:{userId} status online since 1695400000 device web
EXPIRE online_status:{userId} {TTL}
範例：
{
  "status": "online",
  "since": 1695400000,
  "device": "web"
}
好處：
可以存 更多欄位（狀態、登入時間、裝置類型）。
避免為了加新欄位而開新 key。
🔹 2. 全局在線清單
如果你需要快速查「誰在線」，可以用 Set：
SADD online_users {userId}
SREM online_users {userId}
online_users = 當前所有在線用戶 ID
查詢某人是否在線 → SISMEMBER online_users {userId}
查詢在線總數 → SCARD online_users
🔹 3. 好友狀態批量查詢
假設某人有 500 個好友，要查他們誰在線：
方案 A: Redis pipeline
批量 HGET online_status:{friendId} status
適合好友數少（<1k）的情況。
方案 B: 利用 online_users set
SINTER online_users friends:{userId}
friends:{userId} = 該用戶好友清單 (set)
這樣可以 一次得到所有在線好友。
🔹 4. 群組在線查詢
群組可能有上萬人，如果要顯示在線人數：
SINTERCARD online_users group_members:{groupId}
group_members:{groupId} = 該群組所有成員 (set)
SINTERCARD 可以直接返回「交集元素數量」，不用真的取出清單 → O(min(N,M)) 計算。
適合做「群組在線數」顯示。
🔹 5. 最後上線時間 (last seen)
當 user 下線時，除了 status=offline，還要記錄 last_seen：
HSET online_status:{userId} status offline last_seen 1695401000
這樣好友列表可以顯示：
✅ 在線中
⏳ 最後上線時間：5 分鐘前
🔹 6. Pub/Sub 事件格式
狀態變更要廣播，可以用 JSON：
{
  "event": "status_change",
  "userId": "123",
  "status": "offline",
  "timestamp": 1695402000,
  "device": "mobile"
}
透過 NATS / Redis PubSub 發出去，其他 WS server 直接轉發給有訂閱的 client。
🔹 總結
單用戶狀態：Hash，存 status/device/last_seen。
全局在線：Set online_users。
好友/群組查詢：利用 SINTER / SINTERCARD 提高效率。
最後上線時間：存到 Hash，方便顯示。
狀態廣播：透過 Pub/Sub，用 JSON 格式。
👉 這樣設計可以同時滿足：
即時性（WebSocket + Pub/Sub）
查詢效率（Redis Set/Hash 結構）
可擴展性（好友、群組、跨服務器同步）

---------------------------------------
方案 A：RESTful API 改從 MongoDB 讀取
改動點：RESTful API 查詢 online status 時，不只看 in-memory，而是 fallback 去 MongoDB。
流程：
REST API 先查 in-memory
找不到 → 查 MongoDB
讀到之後可再寫回 in-memory 做快取
優點：不用改寫太多邏輯，只要 API handler 多加一層 fallback。
缺點：MongoDB 的 I/O 開銷可能比純 memory 慢（但你可以用 in-memory 做快取緩解）。
方案 B：啟動時預先載入狀態
改動點：服務重啟時，從 MongoDB 把狀態 preload 進 in-memory。
流程：
程式啟動時 → load MongoDB 裡的所有 online 狀態 → 塞回 in-memory。
優點：啟動後 RESTful API 照舊使用 in-memory，無需改 handler。
缺點：若狀態數量大，啟動時間會拉長；而且如果 service 長時間運行，中途 MongoDB 更新但 in-memory 沒同步，可能會有落差。
方案 C：RESTful API 完全切換到 MongoDB
改動點：RESTful API 直接改讀 MongoDB，不再依賴 in-memory。
優點：狀態單一來源，不會有落差。
缺點：這算是「中度改動」，因為要調整整個查詢路徑。
