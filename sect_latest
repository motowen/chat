db.users.aggregate([
  // Step1: 每個 user 展開 supervisor chain
  {
    $graphLookup: {
      from: "users",
      startWith: "$supervisor",
      connectFromField: "supervisor",
      connectToField: "userId",
      as: "supChain",
      depthField: "level"
    }
  },

  // Step2: 找出四層主管（取最近的不同層主管）
  {
    $addFields: {
      sectSupervisor: {
        $first: {
          $filter: {
            input: "$supChain",
            as: "sup",
            cond: { $ne: ["$$sup.sectId", "$sectId"] }
          }
        }
      },
      deptSupervisor: {
        $first: {
          $filter: {
            input: "$supChain",
            as: "sup",
            cond: { $ne: ["$$sup.deptId", "$deptId"] }
          }
        }
      },
      divisionSupervisor: {
        $first: {
          $filter: {
            input: "$supChain",
            as: "sup",
            cond: { $ne: ["$$sup.divisionId", "$divisionId"] }
          }
        }
      },
      functionSupervisor: {
        $first: {
          $filter: {
            input: "$supChain",
            as: "sup",
            cond: { $ne: ["$$sup.functionId", "$functionId"] }
          }
        }
      }
    }
  },

  // Step3: 只保留 userId，避免輸出整個 doc
  {
    $project: {
      sectId: 1,
      deptId: 1,
      divisionId: 1,
      functionId: 1,
      "sectSupervisor.userId": 1,
      "deptSupervisor.userId": 1,
      "divisionSupervisor.userId": 1,
      "functionSupervisor.userId": 1
    }
  },

  // Step4: 聚合成「部門報表」
  {
    $group: {
      _id: {
        sectId: "$sectId",
        deptId: "$deptId",
        divisionId: "$divisionId",
        functionId: "$functionId"
      },
      sectSupervisor: { $addToSet: "$sectSupervisor.userId" },
      deptSupervisor: { $addToSet: "$deptSupervisor.userId" },
      divisionSupervisor: { $addToSet: "$divisionSupervisor.userId" },
      functionSupervisor: { $addToSet: "$functionSupervisor.userId" }
    }
  },

  // Step5: 輸出整齊格式
  {
    $project: {
      _id: 0,
      sectId: "$_id.sectId",
      sectSupervisor: 1,
      deptId: "$_id.deptId",
      deptSupervisor: 1,
      divisionId: "$_id.divisionId",
      divisionSupervisor: 1,
      functionId: "$_id.functionId",
      functionSupervisor: 1
    }
  }
])


✅ 正確的部分
Step1 $graphLookup
用 startWith: "$supervisor" 建出直屬上級 → 上級的上級 → … 的 chain。
as: "supChain" 收到的陣列會依照 depthField 由近到遠排序（level:0 是直屬上司）。
→ 這裡是對的。
Step2 $addFields + $filter
$filter 過濾出「在該層級屬性不同的 supervisor」。
$first 會取到最近的符合者 → 就是你想要的「那一層主管」。
→ 這個邏輯正確。
Step3 $project
避免輸出整個 supervisor 文件，只保留 userId。
→ 做法正確。
Step4 $group
以部門 (sectId / deptId / divisionId / functionId) 為 key，把各 supervisor 集合起來。
→ 這樣可以得到「該部門的主管列表」。
Step5 $project
輸出成乾淨的格式。
→ 沒問題。
⚠️ 潛在問題 / 改進建議
$filter + $first 的安全性
如果 supChain 裡所有人的 sectId 都等於當前 user 的 sectId，$filter 會回傳空陣列 → $first 會是 null。
這在「最高主管」的情境會發生。
→ 建議加上 fallback（例如用 $ifNull 回傳 supChain 最後一個 userId 作為最高主管）。
範例修改：
sectSupervisor: {
  $let: {
    vars: {
      diff: {
        $filter: {
          input: "$supChain",
          as: "sup",
          cond: { $ne: ["$$sup.sectId", "$sectId"] }
        }
      }
    },
    in: {
      $ifNull: [{ $first: "$$diff" }, { $last: "$supChain" }]
    }
  }
}
$group + $addToSet
這裡會產生「陣列」，即使只有一個主管也會輸出成 ["UA"]。
如果你需要單一主管（而不是陣列），要改成 $first（前提是保證唯一）。
範例：
sectSupervisor: { $first: "$sectSupervisor.userId" },
效能問題
$graphLookup 在大 user collection（尤其是樹狀層級深的）會很重。
若這個查詢要頻繁跑，可以考慮 預計算 supervisor chain 存在文件裡（例如 allSupervisors: ["UB","UC",...]），查詢會快很多。
🎯 總結
你的程式在邏輯上能找出各層主管，核心思路是正確的。
不過要注意：
最高主管會變成 null（建議加 fallback）。
輸出 supervisor 會是陣列（是否要改成單一值要看需求）。
效能（如果資料量大，建議改成 denormalization / 預先寫入 allSupervisors）。


假設你的資料如下（簡化版）：
[
  { "sectId": "SA", "deptId": "DA", "divisionId": "DDA", "functionId": "FA", "userId": "UA", "supervisor": "UB" },
  { "sectId": "SB", "deptId": "DA", "divisionId": "DDA", "functionId": "FA", "userId": "UZ", "supervisor": "UA" },
  { "sectId": "SB", "deptId": "DA", "divisionId": "DDA", "functionId": "FA", "userId": "UW", "supervisor": "UA" },
  { "sectId": "DA", "deptId": "DA", "divisionId": "DDA", "functionId": "FA", "userId": "UB", "supervisor": "UC" },
  { "sectId": "SC", "deptId": "DB", "divisionId": "DDA", "functionId": "FA", "userId": "UD", "supervisor": "UB" },
  { "sectId": "SC", "deptId": "DB", "divisionId": "DDA", "functionId": "FA", "userId": "UE", "supervisor": "UD" }
]
Step1: $graphLookup 展開 supervisor chain
Pipeline：
{
  $graphLookup: {
    from: "users",
    startWith: "$supervisor",
    connectFromField: "supervisor",
    connectToField: "userId",
    as: "supChain",
    depthField: "level"
  }
}
解釋：
對每個 user，從 supervisor 開始，沿著 supervisor → userId 走，找到整條上級鏈，放到 supChain。
level 表示距離原 user 的層數（直屬主管 = 0，直屬主管的主管 = 1，…）
產生的中間資料（部分示例）
user UZ
{
  "sectId": "SB",
  "deptId": "DA",
  "divisionId": "DDA",
  "functionId": "FA",
  "userId": "UZ",
  "supervisor": "UA",
  "supChain": [
    { "userId": "UA", "sectId": "SA", "deptId": "DA", "divisionId": "DDA", "functionId": "FA", "supervisor": "UB", "level": 0 },
    { "userId": "UB", "sectId": "DA", "deptId": "DA", "divisionId": "DDA", "functionId": "FA", "supervisor": "UC", "level": 1 },
    { "userId": "UC", "sectId": "DDA", "deptId": "DB", "divisionId": "DDB", "functionId": "FB", "supervisor": null, "level": 2 }
  ]
}
user UA
{
  "sectId": "SA",
  "deptId": "DA",
  "divisionId": "DDA",
  "functionId": "FA",
  "userId": "UA",
  "supervisor": "UB",
  "supChain": [
    { "userId": "UB", "sectId": "DA", "deptId": "DA", "divisionId": "DDA", "functionId": "FA", "supervisor": "UC", "level": 0 },
    { "userId": "UC", "sectId": "DDA", "deptId": "DB", "divisionId": "DDB", "functionId": "FB", "supervisor": null, "level": 1 }
  ]
}
這樣每個 user 都會有一個 supChain 陣列，從直屬主管開始往上列到最頂層。
Step2: $addFields 找四層主管（取最近的不同層主管）
Pipeline：
$addFields: {
  sectSupervisor: { $first: { $filter: { input: "$supChain", as: "sup", cond: { $ne: ["$$sup.sectId", "$sectId"] } } } },
  deptSupervisor: { $first: { $filter: { input: "$supChain", as: "sup", cond: { $ne: ["$$sup.deptId", "$deptId"] } } } },
  divisionSupervisor: { $first: { $filter: { input: "$supChain", as: "sup", cond: { $ne: ["$$sup.divisionId", "$divisionId"] } } } },
  functionSupervisor: { $first: { $filter: { input: "$supChain", as: "sup", cond: { $ne: ["$$sup.functionId", "$functionId"] } } } }
}
解釋：
$filter 找出 supChain 中「該屬性值和自己不同的第一個 supervisor」
$first 取最近的一個 → 就是每層主管
中間資料示例（user UZ）
{
  "userId": "UZ",
  "sectId": "SB",
  "deptId": "DA",
  "divisionId": "DDA",
  "functionId": "FA",
  "supervisor": "UA",
  "supChain": [ ... 如上 ... ],
  "sectSupervisor": { "userId": "UA", "sectId": "SA", ... },
  "deptSupervisor": { "userId": "UB", "deptId": "DA", ... },
  "divisionSupervisor": { "userId": "UC", "divisionId": "DDB", ... },
  "functionSupervisor": { "userId": "UC", "functionId": "FB", ... }
}
注意
如果某一層在 chain 中找不到不同的值，$first 會回 null。
這裡還沒有做 Step3 的 $project → userId 已經可讀，但整個 supervisor doc 還在。
總結：
userId	supChain (userIds)	sectSupervisor	deptSupervisor	divisionSupervisor	functionSupervisor
UZ	[UA, UB, UC]	UA	UB	UC	UC
UA	[UB, UC]	UB	UC	UC	UC
UB	[UC]	UC	UC	UC	UC
UD	[UB, UC]	UB	UC	UC	UC
UE	[UD, UB, UC]	UD	UB	UC	UC
這就是 Step1 + Step2 執行完的中間結果。
